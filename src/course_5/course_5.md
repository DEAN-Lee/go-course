# 类型
Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型。另外还有布尔类型、字符串、字符类型、指针
## 整数类型
Go语言同时提供了有符号和无符号的整数类型。
### 有符号类型
```
int8、int16、int32、int64 分别对应8、16、32、64 bit（二进制位）大小的有符号整数
一个 n-bit 的有符号数的取值范围是从 -2^(n-1) 到 2^(n-1)-1 例如 int8 类型整数的取值范围是从 -128 到 127
```
### 无符号类型
```
 uint8、uint16、uint32 和 uint64 四种无符号整数类型,8、16、32、64 bit（二进制位）大小的无符号整数。
 无符号整数的所有 bit 位都用于表示非负数，取值范围是 0 到 2^(n-1) 例如 uint8 类型整数的取值范围是从 0 到 255
```
## 浮点数
Go语言提供了两种精度的浮点数 float32 和 float64，它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持。
这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：
* 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
* 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
* float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。

一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，
通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。
### 特殊声明方式
浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：
```
const e = .71828 // 0.71828
const f = 1.     // 1
```
很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：
```
const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数
```
用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数
纯文本复制
package main
import (
    "fmt"
    "math"
)
func main() {
    fmt.Printf("%f\n", math.Pi)
    fmt.Printf("%.2f\n", math.Pi)
}

## 复数
复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。
Go语言中复数的类型有两种，分别是  complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。
### 声明语法
```
var name complex128 = complex(x, y)
name := complex(x, y)
```
### 计算复数
使用内置的 complex 函数构建复数，并使用 real 和 imag 函数返回复数的实部和虚部
复数也可以用==和!=进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。
Go语言内置的 math/cmplx 包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的 complex128 类型，因为这些内置的包中都使用 complex128 类型作为参数。
```
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```
## 布尔类型
一个布尔类型的值只有两种：true 或 false。并且==和<等比较操作也会产生布尔型的值。
Go语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。
如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。

布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为，
如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：
```
s != "" && s[0] == 'x'
```
其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。

因为&&的优先级比||高（&& 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：
```
if 'a' <= c && c <= 'z' ||
    'A' <= c && c <= 'Z' ||
    '0' <= c && c <= '9' {
    // ...ASCII字母或数字...
}   
```

Go语言中不允许将整型强制转换为布尔型，代码如下：
```
var n bool
fmt.Println(int(n) * 2)
```
编译错误，输出如下：
```
cannot convert n (type bool) to type int
```
布尔型无法参与数值运算，也无法与其他类型进行转换。
## 字符串

## 字符类型

## 指针


